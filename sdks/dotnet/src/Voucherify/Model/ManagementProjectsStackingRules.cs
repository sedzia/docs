/*
 * Voucherify API
 *
 * Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.
 *
 * The version of the OpenAPI document: v2018-08-01
 * Contact: support@voucherify.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Voucherify.Client.OpenAPIDateConverter;

namespace Voucherify.Model
{
    /// <summary>
    /// Object representing the details of the stacking rules.
    /// </summary>
    [DataContract(Name = "ManagementProjectsStackingRules")]
    public partial class ManagementProjectsStackingRules : IValidatableObject
    {
        /// <summary>
        /// Defines if the discounts are applied by taking into account the initial order amount or the discounted order amount.
        /// </summary>
        /// <value>Defines if the discounts are applied by taking into account the initial order amount or the discounted order amount.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum DiscountCalculationModeEnum
        {
            /// <summary>
            /// Enum INITIALAMOUNT for value: INITIAL_AMOUNT
            /// </summary>
            [EnumMember(Value = "INITIAL_AMOUNT")]
            INITIALAMOUNT = 1,

            /// <summary>
            /// Enum DISCOUNTEDAMOUNT for value: DISCOUNTED_AMOUNT
            /// </summary>
            [EnumMember(Value = "DISCOUNTED_AMOUNT")]
            DISCOUNTEDAMOUNT = 2
        }


        /// <summary>
        /// Defines if the discounts are applied by taking into account the initial order amount or the discounted order amount.
        /// </summary>
        /// <value>Defines if the discounts are applied by taking into account the initial order amount or the discounted order amount.</value>

        [DataMember(Name = "discount_calculation_mode", EmitDefaultValue = true)]
        public DiscountCalculationModeEnum? DiscountCalculationMode
        {
            get{ return _DiscountCalculationMode;}
            set
            {
                _DiscountCalculationMode = value;
                _flagDiscountCalculationMode = true;
            }
        }
        private DiscountCalculationModeEnum? _DiscountCalculationMode;
        private bool _flagDiscountCalculationMode;

        /// <summary>
        /// Returns false as DiscountCalculationMode should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeDiscountCalculationMode()
        {
            return _flagDiscountCalculationMode;
        }
        /// <summary>
        /// Defines the application mode for redeemables. &#x60;\&quot;ALL\&quot;&#x60; means that all redeemables must be validated for the redemption to be successful. &#x60;\&quot;PARTIAL\&quot;&#x60; means that only those redeemables that can be validated will be redeemed. The redeemables that fail validaton will be skipped.
        /// </summary>
        /// <value>Defines the application mode for redeemables. &#x60;\&quot;ALL\&quot;&#x60; means that all redeemables must be validated for the redemption to be successful. &#x60;\&quot;PARTIAL\&quot;&#x60; means that only those redeemables that can be validated will be redeemed. The redeemables that fail validaton will be skipped.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RedeemablesApplicationModeEnum
        {
            /// <summary>
            /// Enum ALL for value: ALL
            /// </summary>
            [EnumMember(Value = "ALL")]
            ALL = 1,

            /// <summary>
            /// Enum PARTIAL for value: PARTIAL
            /// </summary>
            [EnumMember(Value = "PARTIAL")]
            PARTIAL = 2
        }


        /// <summary>
        /// Defines the application mode for redeemables. &#x60;\&quot;ALL\&quot;&#x60; means that all redeemables must be validated for the redemption to be successful. &#x60;\&quot;PARTIAL\&quot;&#x60; means that only those redeemables that can be validated will be redeemed. The redeemables that fail validaton will be skipped.
        /// </summary>
        /// <value>Defines the application mode for redeemables. &#x60;\&quot;ALL\&quot;&#x60; means that all redeemables must be validated for the redemption to be successful. &#x60;\&quot;PARTIAL\&quot;&#x60; means that only those redeemables that can be validated will be redeemed. The redeemables that fail validaton will be skipped.</value>

        [DataMember(Name = "redeemables_application_mode", EmitDefaultValue = true)]
        public RedeemablesApplicationModeEnum? RedeemablesApplicationMode
        {
            get{ return _RedeemablesApplicationMode;}
            set
            {
                _RedeemablesApplicationMode = value;
                _flagRedeemablesApplicationMode = true;
            }
        }
        private RedeemablesApplicationModeEnum? _RedeemablesApplicationMode;
        private bool _flagRedeemablesApplicationMode;

        /// <summary>
        /// Returns false as RedeemablesApplicationMode should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesApplicationMode()
        {
            return _flagRedeemablesApplicationMode;
        }
        /// <summary>
        /// Defines redeemables sorting rule. &#x60;CATEGORY_HIERARCHY&#x60; means that redeemables are applied oaccording to the category priority. &#x60;REQUESTED_ORDER&#x60; means that redeemables are applied in the sequence provided in the request.
        /// </summary>
        /// <value>Defines redeemables sorting rule. &#x60;CATEGORY_HIERARCHY&#x60; means that redeemables are applied oaccording to the category priority. &#x60;REQUESTED_ORDER&#x60; means that redeemables are applied in the sequence provided in the request.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RedeemablesSortingRuleEnum
        {
            /// <summary>
            /// Enum CATEGORYHIERARCHY for value: CATEGORY_HIERARCHY
            /// </summary>
            [EnumMember(Value = "CATEGORY_HIERARCHY")]
            CATEGORYHIERARCHY = 1,

            /// <summary>
            /// Enum REQUESTEDORDER for value: REQUESTED_ORDER
            /// </summary>
            [EnumMember(Value = "REQUESTED_ORDER")]
            REQUESTEDORDER = 2
        }


        /// <summary>
        /// Defines redeemables sorting rule. &#x60;CATEGORY_HIERARCHY&#x60; means that redeemables are applied oaccording to the category priority. &#x60;REQUESTED_ORDER&#x60; means that redeemables are applied in the sequence provided in the request.
        /// </summary>
        /// <value>Defines redeemables sorting rule. &#x60;CATEGORY_HIERARCHY&#x60; means that redeemables are applied oaccording to the category priority. &#x60;REQUESTED_ORDER&#x60; means that redeemables are applied in the sequence provided in the request.</value>

        [DataMember(Name = "redeemables_sorting_rule", EmitDefaultValue = true)]
        public RedeemablesSortingRuleEnum? RedeemablesSortingRule
        {
            get{ return _RedeemablesSortingRule;}
            set
            {
                _RedeemablesSortingRule = value;
                _flagRedeemablesSortingRule = true;
            }
        }
        private RedeemablesSortingRuleEnum? _RedeemablesSortingRule;
        private bool _flagRedeemablesSortingRule;

        /// <summary>
        /// Returns false as RedeemablesSortingRule should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesSortingRule()
        {
            return _flagRedeemablesSortingRule;
        }
        /// <summary>
        /// Defines redeemables products application mode. &#x60;STACK&#x60; means that multiple discounts can be applied to a product. &#x60;ONCE&#x60; means that only one discount can be applied to the same product.
        /// </summary>
        /// <value>Defines redeemables products application mode. &#x60;STACK&#x60; means that multiple discounts can be applied to a product. &#x60;ONCE&#x60; means that only one discount can be applied to the same product.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RedeemablesProductsApplicationModeEnum
        {
            /// <summary>
            /// Enum STACK for value: STACK
            /// </summary>
            [EnumMember(Value = "STACK")]
            STACK = 1,

            /// <summary>
            /// Enum ONCE for value: ONCE
            /// </summary>
            [EnumMember(Value = "ONCE")]
            ONCE = 2
        }


        /// <summary>
        /// Defines redeemables products application mode. &#x60;STACK&#x60; means that multiple discounts can be applied to a product. &#x60;ONCE&#x60; means that only one discount can be applied to the same product.
        /// </summary>
        /// <value>Defines redeemables products application mode. &#x60;STACK&#x60; means that multiple discounts can be applied to a product. &#x60;ONCE&#x60; means that only one discount can be applied to the same product.</value>

        [DataMember(Name = "redeemables_products_application_mode", EmitDefaultValue = true)]
        public RedeemablesProductsApplicationModeEnum? RedeemablesProductsApplicationMode
        {
            get{ return _RedeemablesProductsApplicationMode;}
            set
            {
                _RedeemablesProductsApplicationMode = value;
                _flagRedeemablesProductsApplicationMode = true;
            }
        }
        private RedeemablesProductsApplicationModeEnum? _RedeemablesProductsApplicationMode;
        private bool _flagRedeemablesProductsApplicationMode;

        /// <summary>
        /// Returns false as RedeemablesProductsApplicationMode should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesProductsApplicationMode()
        {
            return _flagRedeemablesProductsApplicationMode;
        }
        /// <summary>
        /// Defines redeemables no effect rule. &#x60;REDEEM_ANYWAY&#x60; means that the redeemable will be redeemed regardless of any restrictions or conditions in place. &#x60;SKIP&#x60; means that the redeemable will be processed only when an applicable effect is calculated.
        /// </summary>
        /// <value>Defines redeemables no effect rule. &#x60;REDEEM_ANYWAY&#x60; means that the redeemable will be redeemed regardless of any restrictions or conditions in place. &#x60;SKIP&#x60; means that the redeemable will be processed only when an applicable effect is calculated.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RedeemablesNoEffectRuleEnum
        {
            /// <summary>
            /// Enum REDEEMANYWAY for value: REDEEM_ANYWAY
            /// </summary>
            [EnumMember(Value = "REDEEM_ANYWAY")]
            REDEEMANYWAY = 1,

            /// <summary>
            /// Enum SKIP for value: SKIP
            /// </summary>
            [EnumMember(Value = "SKIP")]
            SKIP = 2
        }


        /// <summary>
        /// Defines redeemables no effect rule. &#x60;REDEEM_ANYWAY&#x60; means that the redeemable will be redeemed regardless of any restrictions or conditions in place. &#x60;SKIP&#x60; means that the redeemable will be processed only when an applicable effect is calculated.
        /// </summary>
        /// <value>Defines redeemables no effect rule. &#x60;REDEEM_ANYWAY&#x60; means that the redeemable will be redeemed regardless of any restrictions or conditions in place. &#x60;SKIP&#x60; means that the redeemable will be processed only when an applicable effect is calculated.</value>

        [DataMember(Name = "redeemables_no_effect_rule", EmitDefaultValue = true)]
        public RedeemablesNoEffectRuleEnum? RedeemablesNoEffectRule
        {
            get{ return _RedeemablesNoEffectRule;}
            set
            {
                _RedeemablesNoEffectRule = value;
                _flagRedeemablesNoEffectRule = true;
            }
        }
        private RedeemablesNoEffectRuleEnum? _RedeemablesNoEffectRule;
        private bool _flagRedeemablesNoEffectRule;

        /// <summary>
        /// Returns false as RedeemablesNoEffectRule should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesNoEffectRule()
        {
            return _flagRedeemablesNoEffectRule;
        }
        /// <summary>
        /// Defines the rollback mode for the order. &#x60;WITH_ORDER&#x60; is a default setting. The redemption is rolled back together with the data about the order, including related discount values. &#x60;WITHOUT_ORDER&#x60; allows rolling the redemption back without affecting order data, including the applied discount values.
        /// </summary>
        /// <value>Defines the rollback mode for the order. &#x60;WITH_ORDER&#x60; is a default setting. The redemption is rolled back together with the data about the order, including related discount values. &#x60;WITHOUT_ORDER&#x60; allows rolling the redemption back without affecting order data, including the applied discount values.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RedeemablesRollbackOrderModeEnum
        {
            /// <summary>
            /// Enum WITHORDER for value: WITH_ORDER
            /// </summary>
            [EnumMember(Value = "WITH_ORDER")]
            WITHORDER = 1,

            /// <summary>
            /// Enum WITHOUTORDER for value: WITHOUT_ORDER
            /// </summary>
            [EnumMember(Value = "WITHOUT_ORDER")]
            WITHOUTORDER = 2
        }


        /// <summary>
        /// Defines the rollback mode for the order. &#x60;WITH_ORDER&#x60; is a default setting. The redemption is rolled back together with the data about the order, including related discount values. &#x60;WITHOUT_ORDER&#x60; allows rolling the redemption back without affecting order data, including the applied discount values.
        /// </summary>
        /// <value>Defines the rollback mode for the order. &#x60;WITH_ORDER&#x60; is a default setting. The redemption is rolled back together with the data about the order, including related discount values. &#x60;WITHOUT_ORDER&#x60; allows rolling the redemption back without affecting order data, including the applied discount values.</value>

        [DataMember(Name = "redeemables_rollback_order_mode", EmitDefaultValue = true)]
        public RedeemablesRollbackOrderModeEnum? RedeemablesRollbackOrderMode
        {
            get{ return _RedeemablesRollbackOrderMode;}
            set
            {
                _RedeemablesRollbackOrderMode = value;
                _flagRedeemablesRollbackOrderMode = true;
            }
        }
        private RedeemablesRollbackOrderModeEnum? _RedeemablesRollbackOrderMode;
        private bool _flagRedeemablesRollbackOrderMode;

        /// <summary>
        /// Returns false as RedeemablesRollbackOrderMode should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesRollbackOrderMode()
        {
            return _flagRedeemablesRollbackOrderMode;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ManagementProjectsStackingRules" /> class.
        /// </summary>
        /// <param name="id">The unique identifier of the stacking rules..</param>
        /// <param name="exclusiveCategories">Lists the IDs of exclusive categories. A redeemable from a campaign with an exclusive category is the only redeemable to be redeemed when applied with redeemables from other campaigns unless these campaigns are exclusive or joint..</param>
        /// <param name="jointCategories">Lists the IDs of the joint categories. A campaign with a joint category is always applied regardless of the exclusivity of other campaigns..</param>
        /// <param name="redeemablesLimit">Defines how many redeemables can be sent in one request. Note: more redeemables means more processing time..</param>
        /// <param name="applicableRedeemablesLimit">Defines how many redeemables can be applied in one request. The number must be less than or equal to &#x60;redeemables_limit&#x60;. For example, a user can select 30 discounts but only 5 will be applied to the order and the remaining will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;..</param>
        /// <param name="applicableRedeemablesPerCategoryLimit">Defines how many redeemables with the same category can be applied in one request. The number must be less than or equal to &#x60;applicable_redeemables_limit&#x60;. The ones above the limit will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;..</param>
        /// <param name="applicableExclusiveRedeemablesLimit">Defines how many redeemables with an assigned exclusive category can be applied in one request. The ones above the limit will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;..</param>
        /// <param name="applicableExclusiveRedeemablesPerCategoryLimit">Defines how many redeemables with an assigned exclusive category can be applied in one request. The ones above the limit will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;. The number must be less than or equal to &#x60;applicable_exclusive_redeemables_limit&#x60;..</param>
        /// <param name="discountCalculationMode">Defines if the discounts are applied by taking into account the initial order amount or the discounted order amount..</param>
        /// <param name="initialAmountModeCategories">Lists the IDs of the categories that apply a discount based on the initial amount..</param>
        /// <param name="discountedAmountModeCategories">Lists the IDs of the categories that apply a discount based on the discounted amount..</param>
        /// <param name="redeemablesApplicationMode">Defines the application mode for redeemables. &#x60;\&quot;ALL\&quot;&#x60; means that all redeemables must be validated for the redemption to be successful. &#x60;\&quot;PARTIAL\&quot;&#x60; means that only those redeemables that can be validated will be redeemed. The redeemables that fail validaton will be skipped..</param>
        /// <param name="redeemablesSortingRule">Defines redeemables sorting rule. &#x60;CATEGORY_HIERARCHY&#x60; means that redeemables are applied oaccording to the category priority. &#x60;REQUESTED_ORDER&#x60; means that redeemables are applied in the sequence provided in the request..</param>
        /// <param name="redeemablesProductsApplicationMode">Defines redeemables products application mode. &#x60;STACK&#x60; means that multiple discounts can be applied to a product. &#x60;ONCE&#x60; means that only one discount can be applied to the same product..</param>
        /// <param name="redeemablesNoEffectRule">Defines redeemables no effect rule. &#x60;REDEEM_ANYWAY&#x60; means that the redeemable will be redeemed regardless of any restrictions or conditions in place. &#x60;SKIP&#x60; means that the redeemable will be processed only when an applicable effect is calculated..</param>
        /// <param name="noEffectSkipCategories">Lists category IDs. Redeemables with a given category are skipped even if the &#x60;redeemables_no_effect_rule&#x60; is set to &#x60;REDEEM_ANYWAY&#x60;. Category IDs can&#39;t overlap with the IDs in &#x60;no_effect_redeem_anyway_categories&#x60;..</param>
        /// <param name="noEffectRedeemAnywayCategories">Lists category IDs. Redeemables with a given category are redeemed anyway even if the &#x60;redeemables_no_effect_rule&#x60; is set to &#x60;SKIP&#x60;. Category IDs can&#39;t overlap with the IDs in &#x60;no_effect_skip_categories&#x60;..</param>
        /// <param name="redeemablesRollbackOrderMode">Defines the rollback mode for the order. &#x60;WITH_ORDER&#x60; is a default setting. The redemption is rolled back together with the data about the order, including related discount values. &#x60;WITHOUT_ORDER&#x60; allows rolling the redemption back without affecting order data, including the applied discount values..</param>
        /// <param name="createdAt">Timestamp representing the date and time when the stacking rules were created. The value for this parameter is shown in the ISO 8601 format..</param>
        /// <param name="updatedAt">Timestamp representing the date and time when the stacking rules were updated. The value for this parameter is shown in the ISO 8601 format..</param>
        public ManagementProjectsStackingRules(string id = default(string), List<string> exclusiveCategories = default(List<string>), List<string> jointCategories = default(List<string>), int? redeemablesLimit = default(int?), int? applicableRedeemablesLimit = default(int?), int? applicableRedeemablesPerCategoryLimit = default(int?), int? applicableExclusiveRedeemablesLimit = default(int?), int? applicableExclusiveRedeemablesPerCategoryLimit = default(int?), DiscountCalculationModeEnum? discountCalculationMode = default(DiscountCalculationModeEnum?), List<string> initialAmountModeCategories = default(List<string>), List<string> discountedAmountModeCategories = default(List<string>), RedeemablesApplicationModeEnum? redeemablesApplicationMode = default(RedeemablesApplicationModeEnum?), RedeemablesSortingRuleEnum? redeemablesSortingRule = default(RedeemablesSortingRuleEnum?), RedeemablesProductsApplicationModeEnum? redeemablesProductsApplicationMode = default(RedeemablesProductsApplicationModeEnum?), RedeemablesNoEffectRuleEnum? redeemablesNoEffectRule = default(RedeemablesNoEffectRuleEnum?), List<string> noEffectSkipCategories = default(List<string>), List<string> noEffectRedeemAnywayCategories = default(List<string>), RedeemablesRollbackOrderModeEnum? redeemablesRollbackOrderMode = default(RedeemablesRollbackOrderModeEnum?), DateTimeOffset? createdAt = default(DateTimeOffset?), DateTimeOffset? updatedAt = default(DateTimeOffset?))
        {
            this._Id = id;
            if (this.Id != null)
            {
                this._flagId = true;
            }
            this._ExclusiveCategories = exclusiveCategories;
            if (this.ExclusiveCategories != null)
            {
                this._flagExclusiveCategories = true;
            }
            this._JointCategories = jointCategories;
            if (this.JointCategories != null)
            {
                this._flagJointCategories = true;
            }
            this._RedeemablesLimit = redeemablesLimit;
            if (this.RedeemablesLimit != null)
            {
                this._flagRedeemablesLimit = true;
            }
            this._ApplicableRedeemablesLimit = applicableRedeemablesLimit;
            if (this.ApplicableRedeemablesLimit != null)
            {
                this._flagApplicableRedeemablesLimit = true;
            }
            this._ApplicableRedeemablesPerCategoryLimit = applicableRedeemablesPerCategoryLimit;
            if (this.ApplicableRedeemablesPerCategoryLimit != null)
            {
                this._flagApplicableRedeemablesPerCategoryLimit = true;
            }
            this._ApplicableExclusiveRedeemablesLimit = applicableExclusiveRedeemablesLimit;
            if (this.ApplicableExclusiveRedeemablesLimit != null)
            {
                this._flagApplicableExclusiveRedeemablesLimit = true;
            }
            this._ApplicableExclusiveRedeemablesPerCategoryLimit = applicableExclusiveRedeemablesPerCategoryLimit;
            if (this.ApplicableExclusiveRedeemablesPerCategoryLimit != null)
            {
                this._flagApplicableExclusiveRedeemablesPerCategoryLimit = true;
            }
            this._DiscountCalculationMode = discountCalculationMode;
            if (this.DiscountCalculationMode != null)
            {
                this._flagDiscountCalculationMode = true;
            }
            this._InitialAmountModeCategories = initialAmountModeCategories;
            if (this.InitialAmountModeCategories != null)
            {
                this._flagInitialAmountModeCategories = true;
            }
            this._DiscountedAmountModeCategories = discountedAmountModeCategories;
            if (this.DiscountedAmountModeCategories != null)
            {
                this._flagDiscountedAmountModeCategories = true;
            }
            this._RedeemablesApplicationMode = redeemablesApplicationMode;
            if (this.RedeemablesApplicationMode != null)
            {
                this._flagRedeemablesApplicationMode = true;
            }
            this._RedeemablesSortingRule = redeemablesSortingRule;
            if (this.RedeemablesSortingRule != null)
            {
                this._flagRedeemablesSortingRule = true;
            }
            this._RedeemablesProductsApplicationMode = redeemablesProductsApplicationMode;
            if (this.RedeemablesProductsApplicationMode != null)
            {
                this._flagRedeemablesProductsApplicationMode = true;
            }
            this._RedeemablesNoEffectRule = redeemablesNoEffectRule;
            if (this.RedeemablesNoEffectRule != null)
            {
                this._flagRedeemablesNoEffectRule = true;
            }
            this._NoEffectSkipCategories = noEffectSkipCategories;
            if (this.NoEffectSkipCategories != null)
            {
                this._flagNoEffectSkipCategories = true;
            }
            this._NoEffectRedeemAnywayCategories = noEffectRedeemAnywayCategories;
            if (this.NoEffectRedeemAnywayCategories != null)
            {
                this._flagNoEffectRedeemAnywayCategories = true;
            }
            this._RedeemablesRollbackOrderMode = redeemablesRollbackOrderMode;
            if (this.RedeemablesRollbackOrderMode != null)
            {
                this._flagRedeemablesRollbackOrderMode = true;
            }
            this._CreatedAt = createdAt;
            if (this.CreatedAt != null)
            {
                this._flagCreatedAt = true;
            }
            this._UpdatedAt = updatedAt;
            if (this.UpdatedAt != null)
            {
                this._flagUpdatedAt = true;
            }
        }

        /// <summary>
        /// The unique identifier of the stacking rules.
        /// </summary>
        /// <value>The unique identifier of the stacking rules.</value>
        [DataMember(Name = "id", EmitDefaultValue = true)]
        public string Id
        {
            get{ return _Id;}
            set
            {
                _Id = value;
                _flagId = true;
            }
        }
        private string _Id;
        private bool _flagId;

        /// <summary>
        /// Returns false as Id should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeId()
        {
            return _flagId;
        }
        /// <summary>
        /// Lists the IDs of exclusive categories. A redeemable from a campaign with an exclusive category is the only redeemable to be redeemed when applied with redeemables from other campaigns unless these campaigns are exclusive or joint.
        /// </summary>
        /// <value>Lists the IDs of exclusive categories. A redeemable from a campaign with an exclusive category is the only redeemable to be redeemed when applied with redeemables from other campaigns unless these campaigns are exclusive or joint.</value>
        [DataMember(Name = "exclusive_categories", EmitDefaultValue = true)]
        public List<string> ExclusiveCategories
        {
            get{ return _ExclusiveCategories;}
            set
            {
                _ExclusiveCategories = value;
                _flagExclusiveCategories = true;
            }
        }
        private List<string> _ExclusiveCategories;
        private bool _flagExclusiveCategories;

        /// <summary>
        /// Returns false as ExclusiveCategories should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeExclusiveCategories()
        {
            return _flagExclusiveCategories;
        }
        /// <summary>
        /// Lists the IDs of the joint categories. A campaign with a joint category is always applied regardless of the exclusivity of other campaigns.
        /// </summary>
        /// <value>Lists the IDs of the joint categories. A campaign with a joint category is always applied regardless of the exclusivity of other campaigns.</value>
        [DataMember(Name = "joint_categories", EmitDefaultValue = true)]
        public List<string> JointCategories
        {
            get{ return _JointCategories;}
            set
            {
                _JointCategories = value;
                _flagJointCategories = true;
            }
        }
        private List<string> _JointCategories;
        private bool _flagJointCategories;

        /// <summary>
        /// Returns false as JointCategories should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeJointCategories()
        {
            return _flagJointCategories;
        }
        /// <summary>
        /// Defines how many redeemables can be sent in one request. Note: more redeemables means more processing time.
        /// </summary>
        /// <value>Defines how many redeemables can be sent in one request. Note: more redeemables means more processing time.</value>
        [DataMember(Name = "redeemables_limit", EmitDefaultValue = true)]
        public int? RedeemablesLimit
        {
            get{ return _RedeemablesLimit;}
            set
            {
                _RedeemablesLimit = value;
                _flagRedeemablesLimit = true;
            }
        }
        private int? _RedeemablesLimit;
        private bool _flagRedeemablesLimit;

        /// <summary>
        /// Returns false as RedeemablesLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesLimit()
        {
            return _flagRedeemablesLimit;
        }
        /// <summary>
        /// Defines how many redeemables can be applied in one request. The number must be less than or equal to &#x60;redeemables_limit&#x60;. For example, a user can select 30 discounts but only 5 will be applied to the order and the remaining will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;.
        /// </summary>
        /// <value>Defines how many redeemables can be applied in one request. The number must be less than or equal to &#x60;redeemables_limit&#x60;. For example, a user can select 30 discounts but only 5 will be applied to the order and the remaining will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;.</value>
        [DataMember(Name = "applicable_redeemables_limit", EmitDefaultValue = true)]
        public int? ApplicableRedeemablesLimit
        {
            get{ return _ApplicableRedeemablesLimit;}
            set
            {
                _ApplicableRedeemablesLimit = value;
                _flagApplicableRedeemablesLimit = true;
            }
        }
        private int? _ApplicableRedeemablesLimit;
        private bool _flagApplicableRedeemablesLimit;

        /// <summary>
        /// Returns false as ApplicableRedeemablesLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeApplicableRedeemablesLimit()
        {
            return _flagApplicableRedeemablesLimit;
        }
        /// <summary>
        /// Defines how many redeemables with the same category can be applied in one request. The number must be less than or equal to &#x60;applicable_redeemables_limit&#x60;. The ones above the limit will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;.
        /// </summary>
        /// <value>Defines how many redeemables with the same category can be applied in one request. The number must be less than or equal to &#x60;applicable_redeemables_limit&#x60;. The ones above the limit will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;.</value>
        [DataMember(Name = "applicable_redeemables_per_category_limit", EmitDefaultValue = true)]
        public int? ApplicableRedeemablesPerCategoryLimit
        {
            get{ return _ApplicableRedeemablesPerCategoryLimit;}
            set
            {
                _ApplicableRedeemablesPerCategoryLimit = value;
                _flagApplicableRedeemablesPerCategoryLimit = true;
            }
        }
        private int? _ApplicableRedeemablesPerCategoryLimit;
        private bool _flagApplicableRedeemablesPerCategoryLimit;

        /// <summary>
        /// Returns false as ApplicableRedeemablesPerCategoryLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeApplicableRedeemablesPerCategoryLimit()
        {
            return _flagApplicableRedeemablesPerCategoryLimit;
        }
        /// <summary>
        /// Defines how many redeemables with an assigned exclusive category can be applied in one request. The ones above the limit will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;.
        /// </summary>
        /// <value>Defines how many redeemables with an assigned exclusive category can be applied in one request. The ones above the limit will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;.</value>
        [DataMember(Name = "applicable_exclusive_redeemables_limit", EmitDefaultValue = true)]
        public int? ApplicableExclusiveRedeemablesLimit
        {
            get{ return _ApplicableExclusiveRedeemablesLimit;}
            set
            {
                _ApplicableExclusiveRedeemablesLimit = value;
                _flagApplicableExclusiveRedeemablesLimit = true;
            }
        }
        private int? _ApplicableExclusiveRedeemablesLimit;
        private bool _flagApplicableExclusiveRedeemablesLimit;

        /// <summary>
        /// Returns false as ApplicableExclusiveRedeemablesLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeApplicableExclusiveRedeemablesLimit()
        {
            return _flagApplicableExclusiveRedeemablesLimit;
        }
        /// <summary>
        /// Defines how many redeemables with an assigned exclusive category can be applied in one request. The ones above the limit will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;. The number must be less than or equal to &#x60;applicable_exclusive_redeemables_limit&#x60;.
        /// </summary>
        /// <value>Defines how many redeemables with an assigned exclusive category can be applied in one request. The ones above the limit will be &#x60;SKIPPED&#x60; according to the &#x60;redeemables_sorting_rule&#x60;. The number must be less than or equal to &#x60;applicable_exclusive_redeemables_limit&#x60;.</value>
        [DataMember(Name = "applicable_exclusive_redeemables_per_category_limit", EmitDefaultValue = true)]
        public int? ApplicableExclusiveRedeemablesPerCategoryLimit
        {
            get{ return _ApplicableExclusiveRedeemablesPerCategoryLimit;}
            set
            {
                _ApplicableExclusiveRedeemablesPerCategoryLimit = value;
                _flagApplicableExclusiveRedeemablesPerCategoryLimit = true;
            }
        }
        private int? _ApplicableExclusiveRedeemablesPerCategoryLimit;
        private bool _flagApplicableExclusiveRedeemablesPerCategoryLimit;

        /// <summary>
        /// Returns false as ApplicableExclusiveRedeemablesPerCategoryLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeApplicableExclusiveRedeemablesPerCategoryLimit()
        {
            return _flagApplicableExclusiveRedeemablesPerCategoryLimit;
        }
        /// <summary>
        /// Lists the IDs of the categories that apply a discount based on the initial amount.
        /// </summary>
        /// <value>Lists the IDs of the categories that apply a discount based on the initial amount.</value>
        [DataMember(Name = "initial_amount_mode_categories", EmitDefaultValue = true)]
        public List<string> InitialAmountModeCategories
        {
            get{ return _InitialAmountModeCategories;}
            set
            {
                _InitialAmountModeCategories = value;
                _flagInitialAmountModeCategories = true;
            }
        }
        private List<string> _InitialAmountModeCategories;
        private bool _flagInitialAmountModeCategories;

        /// <summary>
        /// Returns false as InitialAmountModeCategories should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeInitialAmountModeCategories()
        {
            return _flagInitialAmountModeCategories;
        }
        /// <summary>
        /// Lists the IDs of the categories that apply a discount based on the discounted amount.
        /// </summary>
        /// <value>Lists the IDs of the categories that apply a discount based on the discounted amount.</value>
        [DataMember(Name = "discounted_amount_mode_categories", EmitDefaultValue = true)]
        public List<string> DiscountedAmountModeCategories
        {
            get{ return _DiscountedAmountModeCategories;}
            set
            {
                _DiscountedAmountModeCategories = value;
                _flagDiscountedAmountModeCategories = true;
            }
        }
        private List<string> _DiscountedAmountModeCategories;
        private bool _flagDiscountedAmountModeCategories;

        /// <summary>
        /// Returns false as DiscountedAmountModeCategories should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeDiscountedAmountModeCategories()
        {
            return _flagDiscountedAmountModeCategories;
        }
        /// <summary>
        /// Lists category IDs. Redeemables with a given category are skipped even if the &#x60;redeemables_no_effect_rule&#x60; is set to &#x60;REDEEM_ANYWAY&#x60;. Category IDs can&#39;t overlap with the IDs in &#x60;no_effect_redeem_anyway_categories&#x60;.
        /// </summary>
        /// <value>Lists category IDs. Redeemables with a given category are skipped even if the &#x60;redeemables_no_effect_rule&#x60; is set to &#x60;REDEEM_ANYWAY&#x60;. Category IDs can&#39;t overlap with the IDs in &#x60;no_effect_redeem_anyway_categories&#x60;.</value>
        [DataMember(Name = "no_effect_skip_categories", EmitDefaultValue = true)]
        public List<string> NoEffectSkipCategories
        {
            get{ return _NoEffectSkipCategories;}
            set
            {
                _NoEffectSkipCategories = value;
                _flagNoEffectSkipCategories = true;
            }
        }
        private List<string> _NoEffectSkipCategories;
        private bool _flagNoEffectSkipCategories;

        /// <summary>
        /// Returns false as NoEffectSkipCategories should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeNoEffectSkipCategories()
        {
            return _flagNoEffectSkipCategories;
        }
        /// <summary>
        /// Lists category IDs. Redeemables with a given category are redeemed anyway even if the &#x60;redeemables_no_effect_rule&#x60; is set to &#x60;SKIP&#x60;. Category IDs can&#39;t overlap with the IDs in &#x60;no_effect_skip_categories&#x60;.
        /// </summary>
        /// <value>Lists category IDs. Redeemables with a given category are redeemed anyway even if the &#x60;redeemables_no_effect_rule&#x60; is set to &#x60;SKIP&#x60;. Category IDs can&#39;t overlap with the IDs in &#x60;no_effect_skip_categories&#x60;.</value>
        [DataMember(Name = "no_effect_redeem_anyway_categories", EmitDefaultValue = true)]
        public List<string> NoEffectRedeemAnywayCategories
        {
            get{ return _NoEffectRedeemAnywayCategories;}
            set
            {
                _NoEffectRedeemAnywayCategories = value;
                _flagNoEffectRedeemAnywayCategories = true;
            }
        }
        private List<string> _NoEffectRedeemAnywayCategories;
        private bool _flagNoEffectRedeemAnywayCategories;

        /// <summary>
        /// Returns false as NoEffectRedeemAnywayCategories should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeNoEffectRedeemAnywayCategories()
        {
            return _flagNoEffectRedeemAnywayCategories;
        }
        /// <summary>
        /// Timestamp representing the date and time when the stacking rules were created. The value for this parameter is shown in the ISO 8601 format.
        /// </summary>
        /// <value>Timestamp representing the date and time when the stacking rules were created. The value for this parameter is shown in the ISO 8601 format.</value>
        /*
        <example>2024-01-02T08:31:46.562Z</example>
        */
        [DataMember(Name = "created_at", EmitDefaultValue = true)]
        public DateTimeOffset? CreatedAt
        {
            get{ return _CreatedAt;}
            set
            {
                _CreatedAt = value;
                _flagCreatedAt = true;
            }
        }
        private DateTimeOffset? _CreatedAt;
        private bool _flagCreatedAt;

        /// <summary>
        /// Returns false as CreatedAt should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeCreatedAt()
        {
            return _flagCreatedAt;
        }
        /// <summary>
        /// Timestamp representing the date and time when the stacking rules were updated. The value for this parameter is shown in the ISO 8601 format.
        /// </summary>
        /// <value>Timestamp representing the date and time when the stacking rules were updated. The value for this parameter is shown in the ISO 8601 format.</value>
        [DataMember(Name = "updated_at", EmitDefaultValue = true)]
        public DateTimeOffset? UpdatedAt
        {
            get{ return _UpdatedAt;}
            set
            {
                _UpdatedAt = value;
                _flagUpdatedAt = true;
            }
        }
        private DateTimeOffset? _UpdatedAt;
        private bool _flagUpdatedAt;

        /// <summary>
        /// Returns false as UpdatedAt should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeUpdatedAt()
        {
            return _flagUpdatedAt;
        }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ManagementProjectsStackingRules {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  ExclusiveCategories: ").Append(ExclusiveCategories).Append("\n");
            sb.Append("  JointCategories: ").Append(JointCategories).Append("\n");
            sb.Append("  RedeemablesLimit: ").Append(RedeemablesLimit).Append("\n");
            sb.Append("  ApplicableRedeemablesLimit: ").Append(ApplicableRedeemablesLimit).Append("\n");
            sb.Append("  ApplicableRedeemablesPerCategoryLimit: ").Append(ApplicableRedeemablesPerCategoryLimit).Append("\n");
            sb.Append("  ApplicableExclusiveRedeemablesLimit: ").Append(ApplicableExclusiveRedeemablesLimit).Append("\n");
            sb.Append("  ApplicableExclusiveRedeemablesPerCategoryLimit: ").Append(ApplicableExclusiveRedeemablesPerCategoryLimit).Append("\n");
            sb.Append("  DiscountCalculationMode: ").Append(DiscountCalculationMode).Append("\n");
            sb.Append("  InitialAmountModeCategories: ").Append(InitialAmountModeCategories).Append("\n");
            sb.Append("  DiscountedAmountModeCategories: ").Append(DiscountedAmountModeCategories).Append("\n");
            sb.Append("  RedeemablesApplicationMode: ").Append(RedeemablesApplicationMode).Append("\n");
            sb.Append("  RedeemablesSortingRule: ").Append(RedeemablesSortingRule).Append("\n");
            sb.Append("  RedeemablesProductsApplicationMode: ").Append(RedeemablesProductsApplicationMode).Append("\n");
            sb.Append("  RedeemablesNoEffectRule: ").Append(RedeemablesNoEffectRule).Append("\n");
            sb.Append("  NoEffectSkipCategories: ").Append(NoEffectSkipCategories).Append("\n");
            sb.Append("  NoEffectRedeemAnywayCategories: ").Append(NoEffectRedeemAnywayCategories).Append("\n");
            sb.Append("  RedeemablesRollbackOrderMode: ").Append(RedeemablesRollbackOrderMode).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // RedeemablesLimit (int?) maximum
            if (this.RedeemablesLimit > (int?)30)
            {
                yield return new ValidationResult("Invalid value for RedeemablesLimit, must be a value less than or equal to 30.", new [] { "RedeemablesLimit" });
            }

            // RedeemablesLimit (int?) minimum
            if (this.RedeemablesLimit < (int?)1)
            {
                yield return new ValidationResult("Invalid value for RedeemablesLimit, must be a value greater than or equal to 1.", new [] { "RedeemablesLimit" });
            }

            // ApplicableRedeemablesLimit (int?) maximum
            if (this.ApplicableRedeemablesLimit > (int?)30)
            {
                yield return new ValidationResult("Invalid value for ApplicableRedeemablesLimit, must be a value less than or equal to 30.", new [] { "ApplicableRedeemablesLimit" });
            }

            // ApplicableRedeemablesLimit (int?) minimum
            if (this.ApplicableRedeemablesLimit < (int?)1)
            {
                yield return new ValidationResult("Invalid value for ApplicableRedeemablesLimit, must be a value greater than or equal to 1.", new [] { "ApplicableRedeemablesLimit" });
            }

            // ApplicableRedeemablesPerCategoryLimit (int?) maximum
            if (this.ApplicableRedeemablesPerCategoryLimit > (int?)30)
            {
                yield return new ValidationResult("Invalid value for ApplicableRedeemablesPerCategoryLimit, must be a value less than or equal to 30.", new [] { "ApplicableRedeemablesPerCategoryLimit" });
            }

            // ApplicableRedeemablesPerCategoryLimit (int?) minimum
            if (this.ApplicableRedeemablesPerCategoryLimit < (int?)1)
            {
                yield return new ValidationResult("Invalid value for ApplicableRedeemablesPerCategoryLimit, must be a value greater than or equal to 1.", new [] { "ApplicableRedeemablesPerCategoryLimit" });
            }

            // ApplicableExclusiveRedeemablesLimit (int?) maximum
            if (this.ApplicableExclusiveRedeemablesLimit > (int?)5)
            {
                yield return new ValidationResult("Invalid value for ApplicableExclusiveRedeemablesLimit, must be a value less than or equal to 5.", new [] { "ApplicableExclusiveRedeemablesLimit" });
            }

            // ApplicableExclusiveRedeemablesLimit (int?) minimum
            if (this.ApplicableExclusiveRedeemablesLimit < (int?)1)
            {
                yield return new ValidationResult("Invalid value for ApplicableExclusiveRedeemablesLimit, must be a value greater than or equal to 1.", new [] { "ApplicableExclusiveRedeemablesLimit" });
            }

            // ApplicableExclusiveRedeemablesPerCategoryLimit (int?) maximum
            if (this.ApplicableExclusiveRedeemablesPerCategoryLimit > (int?)30)
            {
                yield return new ValidationResult("Invalid value for ApplicableExclusiveRedeemablesPerCategoryLimit, must be a value less than or equal to 30.", new [] { "ApplicableExclusiveRedeemablesPerCategoryLimit" });
            }

            // ApplicableExclusiveRedeemablesPerCategoryLimit (int?) minimum
            if (this.ApplicableExclusiveRedeemablesPerCategoryLimit < (int?)1)
            {
                yield return new ValidationResult("Invalid value for ApplicableExclusiveRedeemablesPerCategoryLimit, must be a value greater than or equal to 1.", new [] { "ApplicableExclusiveRedeemablesPerCategoryLimit" });
            }

            yield break;
        }
    }

}
